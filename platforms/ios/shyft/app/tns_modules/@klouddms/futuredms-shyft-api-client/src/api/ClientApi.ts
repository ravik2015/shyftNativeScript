/**
 * Shyft Auto
 * An api to run the client and administration of the shyft auto app.
 *
 * OpenAPI spec version: 0.2.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH }                                         from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class ClientApi {
    protected basePath = 'https://uat.futuredms.com/shyft-api/v1';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }
	
	/**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
   private extendObj<T1,T2>(objA: T1, objB: T2): T1 & T2 {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                (<T1 & T2>objA)[key] = (<T1 & T2>objB)[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * Appointments allow clients to schedule service.
     * Retrieves an appointment by id
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.AppointmentSearchModel> {
        return this.appointmentAppointmentIdGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The location of an appointment pickup
     * An appointment location
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdLocationGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.LocationModel> {
        return this.appointmentAppointmentIdLocationGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Appointments have a location for pickup
     * Post a location for an appointment
     * @param appointmentId The id of the appointment
     * @param appointmentLocationRequest The location of an appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdLocationPut(appointmentId: string, appointmentLocationRequest: models.LocationModel, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.appointmentAppointmentIdLocationPutWithHttpInfo(appointmentId, appointmentLocationRequest, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Appointments include pickups
     * Retrieves the pickup data associated with an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPickupGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.PickupSearchModel> {
        return this.appointmentAppointmentIdPickupGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Appointments allow clients to schedule service
     * Puts an appointment at id
     * @param appointmentId the id of the appointment
     * @param appointmentRequest the appointment being added to the system
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPut(appointmentId: string, appointmentRequest: models.AppointmentModel, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.appointmentAppointmentIdPutWithHttpInfo(appointmentId, appointmentRequest, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceSelectionSearchModel>> {
        return this.appointmentAppointmentIdServiceSelectionGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param serviceSelectionId the id of the association between a user selected service and an appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionServiceSelectionIdGet(appointmentId: string, serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.ServiceSelectionSearchModel> {
        return this.appointmentAppointmentIdServiceSelectionServiceSelectionIdGetWithHttpInfo(appointmentId, serviceSelectionId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param serviceSelectionId the id of the association between a user selected service and an appointment
     * @param serviceSelection Model to send update the to the appointment&#39;s service selection
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionServiceSelectionIdPut(appointmentId: string, serviceSelectionId: string, serviceSelection: models.ServiceSelectionModel, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.appointmentAppointmentIdServiceSelectionServiceSelectionIdPutWithHttpInfo(appointmentId, serviceSelectionId, serviceSelection, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * User makes an appointment
     * Returns the user of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdUserGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.UserProfileModel> {
        return this.appointmentAppointmentIdUserGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The vehicle of an appointment
     * Adds a vehicle to this appointment
     * @param appointmentId Appointment Id
     * @param appointmentVehicleRequest Appointment Vehicle Request
     * @param authorization Authorization header
     */
    public appointmentAppointmentIdVehiclePut(appointmentId: string, appointmentVehicleRequest: models.AppointmentVehicleModel, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.appointmentAppointmentIdVehiclePutWithHttpInfo(appointmentId, appointmentVehicleRequest, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Appointments allow clients to schedule service
     * Retrieves a list of appointments
     * @param authorization Authorization Header
     * @param vendorId vendorId
     */
    public appointmentGet(authorization?: string, vendorId?: string, extraHttpRequestParams?: any): Observable<Array<models.AppointmentSearchModel>> {
        return this.appointmentGetWithHttpInfo(authorization, vendorId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The location of the pickup
     * Stores the coordinates and reverse lookup address where available
     * @param authorization Authorization Header
     */
    public locationGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.LocationModel>> {
        return this.locationGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Users submit location data for pickups
     * Retrieves a location by id
     * @param locationId 
     * @param authorization Authorization Header
     */
    public locationLocationIdGet(locationId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.LocationModel> {
        return this.locationLocationIdGetWithHttpInfo(locationId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returneed for pickups
     * Retrieves a list of pickups
     * @param authorization Authorization Header
     */
    public pickupGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.PickupSearchModel>> {
        return this.pickupGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returned for pickups
     * Returns a pickup with the given id
     * @param pickupId 
     * @param authorization Authorization Header
     */
    public pickupPickupIdGet(pickupId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.PickupSearchModel> {
        return this.pickupPickupIdGetWithHttpInfo(pickupId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param authorization Authorization Header
     */
    public serviceGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceModel>> {
        return this.serviceGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Service Selections represent user selected service items
     * Returns an collection of service selections
     * @param authorization Authorization Header
     */
    public serviceSelectionGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceSelectionSearchModel>> {
        return this.serviceSelectionGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Service Selection represents a user selected service
     * Returns the selection with the given id
     * @param serviceSelectionId the id of the service selection (an association between an appointment and a service)
     * @param authorization Authorization Header
     */
    public serviceSelectionServiceSelectionIdGet(serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.ServiceSelectionSearchModel> {
        return this.serviceSelectionServiceSelectionIdGetWithHttpInfo(serviceSelectionId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param serviceId the id of the service
     * @param authorization Authorization Header
     */
    public serviceServiceIdGet(serviceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.ServiceModel> {
        return this.serviceServiceIdGetWithHttpInfo(serviceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Users
     * Returns a list of users
     * @param authorization Authorization Header
     */
    public userGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.UserProfileModel>> {
        return this.userGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdGet(userId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.UserProfileModel> {
        return this.userUserIdGetWithHttpInfo(userId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdPut(userId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.UserProfileModel> {
        return this.userUserIdPutWithHttpInfo(userId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Remove Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdDelete(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.vendorVendorIdServicesVendorServiceIdDeleteWithHttpInfo(vendorId, vendorServiceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Retrieving Vendor Services
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdGet(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.vendorVendorIdServicesVendorServiceIdGetWithHttpInfo(vendorId, vendorServiceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdPut(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.vendorVendorIdServicesVendorServiceIdPutWithHttpInfo(vendorId, vendorServiceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Appointments allow clients to schedule service.
     * Retrieves an appointment by id
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The location of an appointment pickup
     * An appointment location
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdLocationGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/location`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdLocationGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Appointments have a location for pickup
     * Post a location for an appointment
     * @param appointmentId The id of the appointment
     * @param appointmentLocationRequest The location of an appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdLocationPutWithHttpInfo(appointmentId: string, appointmentLocationRequest: models.LocationModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/location`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdLocationPut.');
        }
        // verify required parameter 'appointmentLocationRequest' is not null or undefined
        if (appointmentLocationRequest === null || appointmentLocationRequest === undefined) {
            throw new Error('Required parameter appointmentLocationRequest was null or undefined when calling appointmentAppointmentIdLocationPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: appointmentLocationRequest == null ? '' : JSON.stringify(appointmentLocationRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Appointments include pickups
     * Retrieves the pickup data associated with an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPickupGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/pickup`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdPickupGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Appointments allow clients to schedule service
     * Puts an appointment at id
     * @param appointmentId the id of the appointment
     * @param appointmentRequest the appointment being added to the system
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPutWithHttpInfo(appointmentId: string, appointmentRequest: models.AppointmentModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdPut.');
        }
        // verify required parameter 'appointmentRequest' is not null or undefined
        if (appointmentRequest === null || appointmentRequest === undefined) {
            throw new Error('Required parameter appointmentRequest was null or undefined when calling appointmentAppointmentIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: appointmentRequest == null ? '' : JSON.stringify(appointmentRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/service-selection`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdServiceSelectionGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param serviceSelectionId the id of the association between a user selected service and an appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionServiceSelectionIdGetWithHttpInfo(appointmentId: string, serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/service-selection/${serviceSelectionId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdServiceSelectionServiceSelectionIdGet.');
        }
        // verify required parameter 'serviceSelectionId' is not null or undefined
        if (serviceSelectionId === null || serviceSelectionId === undefined) {
            throw new Error('Required parameter serviceSelectionId was null or undefined when calling appointmentAppointmentIdServiceSelectionServiceSelectionIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param serviceSelectionId the id of the association between a user selected service and an appointment
     * @param serviceSelection Model to send update the to the appointment&#39;s service selection
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionServiceSelectionIdPutWithHttpInfo(appointmentId: string, serviceSelectionId: string, serviceSelection: models.ServiceSelectionModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/service-selection/${serviceSelectionId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdServiceSelectionServiceSelectionIdPut.');
        }
        // verify required parameter 'serviceSelectionId' is not null or undefined
        if (serviceSelectionId === null || serviceSelectionId === undefined) {
            throw new Error('Required parameter serviceSelectionId was null or undefined when calling appointmentAppointmentIdServiceSelectionServiceSelectionIdPut.');
        }
        // verify required parameter 'serviceSelection' is not null or undefined
        if (serviceSelection === null || serviceSelection === undefined) {
            throw new Error('Required parameter serviceSelection was null or undefined when calling appointmentAppointmentIdServiceSelectionServiceSelectionIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: serviceSelection == null ? '' : JSON.stringify(serviceSelection), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * User makes an appointment
     * Returns the user of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdUserGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/user`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdUserGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The vehicle of an appointment
     * Adds a vehicle to this appointment
     * @param appointmentId Appointment Id
     * @param appointmentVehicleRequest Appointment Vehicle Request
     * @param authorization Authorization header
     */
    public appointmentAppointmentIdVehiclePutWithHttpInfo(appointmentId: string, appointmentVehicleRequest: models.AppointmentVehicleModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/vehicle`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdVehiclePut.');
        }
        // verify required parameter 'appointmentVehicleRequest' is not null or undefined
        if (appointmentVehicleRequest === null || appointmentVehicleRequest === undefined) {
            throw new Error('Required parameter appointmentVehicleRequest was null or undefined when calling appointmentAppointmentIdVehiclePut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: appointmentVehicleRequest == null ? '' : JSON.stringify(appointmentVehicleRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Appointments allow clients to schedule service
     * Retrieves a list of appointments
     * @param authorization Authorization Header
     * @param vendorId vendorId
     */
    public appointmentGetWithHttpInfo(authorization?: string, vendorId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (vendorId !== undefined) {
            queryParameters.set('vendor_id', <any>vendorId);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The location of the pickup
     * Stores the coordinates and reverse lookup address where available
     * @param authorization Authorization Header
     */
    public locationGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/location`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Users submit location data for pickups
     * Retrieves a location by id
     * @param locationId 
     * @param authorization Authorization Header
     */
    public locationLocationIdGetWithHttpInfo(locationId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/location/${locationId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling locationLocationIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returneed for pickups
     * Retrieves a list of pickups
     * @param authorization Authorization Header
     */
    public pickupGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/pickup`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returned for pickups
     * Returns a pickup with the given id
     * @param pickupId 
     * @param authorization Authorization Header
     */
    public pickupPickupIdGetWithHttpInfo(pickupId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/pickup/${pickupId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pickupId' is not null or undefined
        if (pickupId === null || pickupId === undefined) {
            throw new Error('Required parameter pickupId was null or undefined when calling pickupPickupIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param authorization Authorization Header
     */
    public serviceGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Service Selections represent user selected service items
     * Returns an collection of service selections
     * @param authorization Authorization Header
     */
    public serviceSelectionGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-selection`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Service Selection represents a user selected service
     * Returns the selection with the given id
     * @param serviceSelectionId the id of the service selection (an association between an appointment and a service)
     * @param authorization Authorization Header
     */
    public serviceSelectionServiceSelectionIdGetWithHttpInfo(serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-selection/${serviceSelectionId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceSelectionId' is not null or undefined
        if (serviceSelectionId === null || serviceSelectionId === undefined) {
            throw new Error('Required parameter serviceSelectionId was null or undefined when calling serviceSelectionServiceSelectionIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param serviceId the id of the service
     * @param authorization Authorization Header
     */
    public serviceServiceIdGetWithHttpInfo(serviceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service/${serviceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling serviceServiceIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Users
     * Returns a list of users
     * @param authorization Authorization Header
     */
    public userGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/user`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdGetWithHttpInfo(userId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/user/${userId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling userUserIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdPutWithHttpInfo(userId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/user/${userId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling userUserIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Remove Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdDeleteWithHttpInfo(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/vendor/${vendorId}/services/${vendorServiceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling vendorVendorIdServicesVendorServiceIdDelete.');
        }
        // verify required parameter 'vendorServiceId' is not null or undefined
        if (vendorServiceId === null || vendorServiceId === undefined) {
            throw new Error('Required parameter vendorServiceId was null or undefined when calling vendorVendorIdServicesVendorServiceIdDelete.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieving Vendor Services
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdGetWithHttpInfo(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/vendor/${vendorId}/services/${vendorServiceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling vendorVendorIdServicesVendorServiceIdGet.');
        }
        // verify required parameter 'vendorServiceId' is not null or undefined
        if (vendorServiceId === null || vendorServiceId === undefined) {
            throw new Error('Required parameter vendorServiceId was null or undefined when calling vendorVendorIdServicesVendorServiceIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdPutWithHttpInfo(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/vendor/${vendorId}/services/${vendorServiceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling vendorVendorIdServicesVendorServiceIdPut.');
        }
        // verify required parameter 'vendorServiceId' is not null or undefined
        if (vendorServiceId === null || vendorServiceId === undefined) {
            throw new Error('Required parameter vendorServiceId was null or undefined when calling vendorVendorIdServicesVendorServiceIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
