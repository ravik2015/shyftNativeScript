/**
 * Shyft Auto
 * An api to run the client and administration of the shyft auto app.
 *
 * OpenAPI spec version: 0.2.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH }                                         from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class AdminApi {
    protected basePath = 'https://uat.futuredms.com/shyft-api/v1';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }
	
	/**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1,T2>(objA: T1, objB: T2): T1 & T2 {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                (<T1 & T2>objA)[key] = (<T1 & T2>objB)[key];
            }
        }
        return <T1&T2>objA;
    }


    /**
     * Appointments allow clients to schedule service.
     * Retrieves an appointment by id
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.AppointmentSearchModel> {
        return this.appointmentAppointmentIdGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The location of an appointment pickup
     * An appointment location
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdLocationGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.LocationModel> {
        return this.appointmentAppointmentIdLocationGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Appointments include pickups
     * Retrieves the pickup data associated with an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPickupGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.PickupSearchModel> {
        return this.appointmentAppointmentIdPickupGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Appointments include pickups
     * Updates the pickup data associated with an appointment
     * @param appointmentId The id of the appointment
     * @param pickupRequest The pickup model for update
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPickupPut(appointmentId: string, pickupRequest: models.PickupModel, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.appointmentAppointmentIdPickupPutWithHttpInfo(appointmentId, pickupRequest, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceSelectionSearchModel>> {
        return this.appointmentAppointmentIdServiceSelectionGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param serviceSelectionId the id of the association between a user selected service and an appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionServiceSelectionIdGet(appointmentId: string, serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.ServiceSelectionSearchModel> {
        return this.appointmentAppointmentIdServiceSelectionServiceSelectionIdGetWithHttpInfo(appointmentId, serviceSelectionId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * User makes an appointment
     * Returns the user of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdUserGet(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.UserProfileModel> {
        return this.appointmentAppointmentIdUserGetWithHttpInfo(appointmentId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Appointments allow clients to schedule service
     * Retrieves a list of appointments
     * @param authorization Authorization Header
     * @param vendorId vendorId
     */
    public appointmentGet(authorization?: string, vendorId?: string, extraHttpRequestParams?: any): Observable<Array<models.AppointmentSearchModel>> {
        return this.appointmentGetWithHttpInfo(authorization, vendorId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param driverId the id of the driver
     * @param authorization Authorization Header
     * @param userId 
     */
    public driversDriverIdPut(driverId: string, authorization?: string, userId?: models.DriverProfile, extraHttpRequestParams?: any): Observable<{}> {
        return this.driversDriverIdPutWithHttpInfo(driverId, authorization, userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param authorization Authorization Header
     */
    public driversGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.NewUserProfileModel>> {
        return this.driversGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param authorization Authorization Header
     */
    public fleetGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.FleetSearchModel>> {
        return this.fleetGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The location of the pickup
     * Stores the coordinates and reverse lookup address where available
     * @param authorization Authorization Header
     */
    public locationGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.LocationModel>> {
        return this.locationGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Users submit location data for pickups
     * Retrieves a location by id
     * @param locationId 
     * @param authorization Authorization Header
     */
    public locationLocationIdGet(locationId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.LocationModel> {
        return this.locationLocationIdGetWithHttpInfo(locationId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returneed for pickups
     * Retrieves a list of pickups
     * @param authorization Authorization Header
     */
    public pickupGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.PickupSearchModel>> {
        return this.pickupGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returned for pickups
     * Returns a pickup with the given id
     * @param pickupId 
     * @param authorization Authorization Header
     */
    public pickupPickupIdGet(pickupId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.PickupSearchModel> {
        return this.pickupPickupIdGetWithHttpInfo(pickupId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Services are categorized
     * 
     * @param authorization Authorization Header
     */
    public serviceCategoryGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceCategorySearchModel>> {
        return this.serviceCategoryGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param serviceCategoryId The id of the service category
     * @param authorization the authorization token
     */
    public serviceCategoryServiceCategoryIdGet(serviceCategoryId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.ServiceCategorySearchModel> {
        return this.serviceCategoryServiceCategoryIdGetWithHttpInfo(serviceCategoryId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param serviceCategoryId The id of the service category
     * @param serviceCategoryRequest Add or update service category data
     * @param authorization the authorization token
     */
    public serviceCategoryServiceCategoryIdPut(serviceCategoryId: string, serviceCategoryRequest: models.ServiceCategoryModel, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceCategoryServiceCategoryIdPutWithHttpInfo(serviceCategoryId, serviceCategoryRequest, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param authorization Authorization Header
     */
    public serviceGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceModel>> {
        return this.serviceGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Service Selections represent user selected service items
     * Returns an collection of service selections
     * @param authorization Authorization Header
     */
    public serviceSelectionGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.ServiceSelectionSearchModel>> {
        return this.serviceSelectionGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Service Selection represents a user selected service
     * Returns the selection with the given id
     * @param serviceSelectionId the id of the service selection (an association between an appointment and a service)
     * @param authorization Authorization Header
     */
    public serviceSelectionServiceSelectionIdGet(serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.ServiceSelectionSearchModel> {
        return this.serviceSelectionServiceSelectionIdGetWithHttpInfo(serviceSelectionId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param serviceId the id of the service
     * @param authorization Authorization Header
     */
    public serviceServiceIdGet(serviceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.ServiceModel> {
        return this.serviceServiceIdGetWithHttpInfo(serviceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Services can be added to enhance a vendor&#39;s offering
     * Adds or updates a vendor&#39;s service
     * @param serviceId the id of the service
     * @param servicePayload The details of the service
     * @param authorization Authorization Header
     */
    public serviceServiceIdPut(serviceId: string, servicePayload: models.ServiceModel, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.serviceServiceIdPutWithHttpInfo(serviceId, servicePayload, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Users
     * Returns a list of users
     * @param authorization Authorization Header
     */
    public userGet(authorization?: string, extraHttpRequestParams?: any): Observable<Array<models.UserProfileModel>> {
        return this.userGetWithHttpInfo(authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The user
     * Returns a user profile
     * @param newUserProfileRequest the request body
     * @param authorization Authorization Header
     */
    public userPost(newUserProfileRequest: models.NewUserProfileModel, authorization?: string, extraHttpRequestParams?: any): Observable<models.UserProfileModel> {
        return this.userPostWithHttpInfo(newUserProfileRequest, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdGet(userId: string, authorization?: string, extraHttpRequestParams?: any): Observable<models.UserProfileModel> {
        return this.userUserIdGetWithHttpInfo(userId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdPut(userId: string, userProfileRequest: models.NewUserProfileModel, authorization?: string, extraHttpRequestParams?: any): Observable<models.NewUserProfileModel> {
        return this.userUserIdPutWithHttpInfo(userId, userProfileRequest, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param vendorId 
     * @param vendorLocationRequest The location object of the vendor
     */
    public vendorVendorIdLocationPut(vendorId: string, vendorLocationRequest: models.LocationModel, extraHttpRequestParams?: any): Observable<{}> {
        return this.vendorVendorIdLocationPutWithHttpInfo(vendorId, vendorLocationRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Remove Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdDelete(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.vendorVendorIdServicesVendorServiceIdDeleteWithHttpInfo(vendorId, vendorServiceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Retrieving Vendor Services
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdGet(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.vendorVendorIdServicesVendorServiceIdGetWithHttpInfo(vendorId, vendorServiceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdPut(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.vendorVendorIdServicesVendorServiceIdPutWithHttpInfo(vendorId, vendorServiceId, authorization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Appointments allow clients to schedule service.
     * Retrieves an appointment by id
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The location of an appointment pickup
     * An appointment location
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdLocationGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/location`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdLocationGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Appointments include pickups
     * Retrieves the pickup data associated with an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPickupGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/pickup`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdPickupGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Appointments include pickups
     * Updates the pickup data associated with an appointment
     * @param appointmentId The id of the appointment
     * @param pickupRequest The pickup model for update
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdPickupPutWithHttpInfo(appointmentId: string, pickupRequest: models.PickupModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/pickup`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdPickupPut.');
        }
        // verify required parameter 'pickupRequest' is not null or undefined
        if (pickupRequest === null || pickupRequest === undefined) {
            throw new Error('Required parameter pickupRequest was null or undefined when calling appointmentAppointmentIdPickupPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: pickupRequest == null ? '' : JSON.stringify(pickupRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/service-selection`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdServiceSelectionGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The appointment service selections
     * Returns the service selections of an appointment
     * @param appointmentId The id of the appointment
     * @param serviceSelectionId the id of the association between a user selected service and an appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdServiceSelectionServiceSelectionIdGetWithHttpInfo(appointmentId: string, serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/service-selection/${serviceSelectionId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdServiceSelectionServiceSelectionIdGet.');
        }
        // verify required parameter 'serviceSelectionId' is not null or undefined
        if (serviceSelectionId === null || serviceSelectionId === undefined) {
            throw new Error('Required parameter serviceSelectionId was null or undefined when calling appointmentAppointmentIdServiceSelectionServiceSelectionIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * User makes an appointment
     * Returns the user of an appointment
     * @param appointmentId The id of the appointment
     * @param authorization Authorization Header
     */
    public appointmentAppointmentIdUserGetWithHttpInfo(appointmentId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment/${appointmentId}/user`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'appointmentId' is not null or undefined
        if (appointmentId === null || appointmentId === undefined) {
            throw new Error('Required parameter appointmentId was null or undefined when calling appointmentAppointmentIdUserGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Appointments allow clients to schedule service
     * Retrieves a list of appointments
     * @param authorization Authorization Header
     * @param vendorId vendorId
     */
    public appointmentGetWithHttpInfo(authorization?: string, vendorId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/appointment`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (vendorId !== undefined) {
            queryParameters.set('vendor_id', <any>vendorId);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param driverId the id of the driver
     * @param authorization Authorization Header
     * @param userId 
     */
    public driversDriverIdPutWithHttpInfo(driverId: string, authorization?: string, userId?: models.DriverProfile, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/drivers/${driverId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling driversDriverIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: userId == null ? '' : JSON.stringify(userId), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authorization Authorization Header
     */
    public driversGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/drivers`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authorization Authorization Header
     */
    public fleetGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/fleet`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The location of the pickup
     * Stores the coordinates and reverse lookup address where available
     * @param authorization Authorization Header
     */
    public locationGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/location`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Users submit location data for pickups
     * Retrieves a location by id
     * @param locationId 
     * @param authorization Authorization Header
     */
    public locationLocationIdGetWithHttpInfo(locationId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/location/${locationId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling locationLocationIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returneed for pickups
     * Retrieves a list of pickups
     * @param authorization Authorization Header
     */
    public pickupGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/pickup`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Drivers, Car Model and Color, and time of departure and eta are data returned for pickups
     * Returns a pickup with the given id
     * @param pickupId 
     * @param authorization Authorization Header
     */
    public pickupPickupIdGetWithHttpInfo(pickupId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/pickup/${pickupId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pickupId' is not null or undefined
        if (pickupId === null || pickupId === undefined) {
            throw new Error('Required parameter pickupId was null or undefined when calling pickupPickupIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Services are categorized
     * 
     * @param authorization Authorization Header
     */
    public serviceCategoryGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-category`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param serviceCategoryId The id of the service category
     * @param authorization the authorization token
     */
    public serviceCategoryServiceCategoryIdGetWithHttpInfo(serviceCategoryId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-category/${serviceCategoryId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceCategoryId' is not null or undefined
        if (serviceCategoryId === null || serviceCategoryId === undefined) {
            throw new Error('Required parameter serviceCategoryId was null or undefined when calling serviceCategoryServiceCategoryIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param serviceCategoryId The id of the service category
     * @param serviceCategoryRequest Add or update service category data
     * @param authorization the authorization token
     */
    public serviceCategoryServiceCategoryIdPutWithHttpInfo(serviceCategoryId: string, serviceCategoryRequest: models.ServiceCategoryModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-category/${serviceCategoryId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceCategoryId' is not null or undefined
        if (serviceCategoryId === null || serviceCategoryId === undefined) {
            throw new Error('Required parameter serviceCategoryId was null or undefined when calling serviceCategoryServiceCategoryIdPut.');
        }
        // verify required parameter 'serviceCategoryRequest' is not null or undefined
        if (serviceCategoryRequest === null || serviceCategoryRequest === undefined) {
            throw new Error('Required parameter serviceCategoryRequest was null or undefined when calling serviceCategoryServiceCategoryIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: serviceCategoryRequest == null ? '' : JSON.stringify(serviceCategoryRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param authorization Authorization Header
     */
    public serviceGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Service Selections represent user selected service items
     * Returns an collection of service selections
     * @param authorization Authorization Header
     */
    public serviceSelectionGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-selection`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Service Selection represents a user selected service
     * Returns the selection with the given id
     * @param serviceSelectionId the id of the service selection (an association between an appointment and a service)
     * @param authorization Authorization Header
     */
    public serviceSelectionServiceSelectionIdGetWithHttpInfo(serviceSelectionId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service-selection/${serviceSelectionId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceSelectionId' is not null or undefined
        if (serviceSelectionId === null || serviceSelectionId === undefined) {
            throw new Error('Required parameter serviceSelectionId was null or undefined when calling serviceSelectionServiceSelectionIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Services are specific jobs advertised for the conceirge pickup
     * Returns a list of services
     * @param serviceId the id of the service
     * @param authorization Authorization Header
     */
    public serviceServiceIdGetWithHttpInfo(serviceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service/${serviceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling serviceServiceIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Services can be added to enhance a vendor&#39;s offering
     * Adds or updates a vendor&#39;s service
     * @param serviceId the id of the service
     * @param servicePayload The details of the service
     * @param authorization Authorization Header
     */
    public serviceServiceIdPutWithHttpInfo(serviceId: string, servicePayload: models.ServiceModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/service/${serviceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling serviceServiceIdPut.');
        }
        // verify required parameter 'servicePayload' is not null or undefined
        if (servicePayload === null || servicePayload === undefined) {
            throw new Error('Required parameter servicePayload was null or undefined when calling serviceServiceIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: servicePayload == null ? '' : JSON.stringify(servicePayload), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Users
     * Returns a list of users
     * @param authorization Authorization Header
     */
    public userGetWithHttpInfo(authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/user`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The user
     * Returns a user profile
     * @param newUserProfileRequest the request body
     * @param authorization Authorization Header
     */
    public userPostWithHttpInfo(newUserProfileRequest: models.NewUserProfileModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/user`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'newUserProfileRequest' is not null or undefined
        if (newUserProfileRequest === null || newUserProfileRequest === undefined) {
            throw new Error('Required parameter newUserProfileRequest was null or undefined when calling userPost.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: newUserProfileRequest == null ? '' : JSON.stringify(newUserProfileRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdGetWithHttpInfo(userId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/user/${userId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling userUserIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * The user
     * Returns a user profile
     * @param userId the id of the user
     * @param authorization Authorization Header
     */
    public userUserIdPutWithHttpInfo(userId: string, userProfileRequest: models.NewUserProfileModel, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/user/${userId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling userUserIdPut.');
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            body: userProfileRequest == null ? '' : JSON.stringify(userProfileRequest), 
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param vendorId 
     * @param vendorLocationRequest The location object of the vendor
     */
    public vendorVendorIdLocationPutWithHttpInfo(vendorId: string, vendorLocationRequest: models.LocationModel, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/vendor/${vendorId}/location`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling vendorVendorIdLocationPut.');
        }
        // verify required parameter 'vendorLocationRequest' is not null or undefined
        if (vendorLocationRequest === null || vendorLocationRequest === undefined) {
            throw new Error('Required parameter vendorLocationRequest was null or undefined when calling vendorVendorIdLocationPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: vendorLocationRequest == null ? '' : JSON.stringify(vendorLocationRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Remove Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdDeleteWithHttpInfo(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/vendor/${vendorId}/services/${vendorServiceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling vendorVendorIdServicesVendorServiceIdDelete.');
        }
        // verify required parameter 'vendorServiceId' is not null or undefined
        if (vendorServiceId === null || vendorServiceId === undefined) {
            throw new Error('Required parameter vendorServiceId was null or undefined when calling vendorVendorIdServicesVendorServiceIdDelete.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieving Vendor Services
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdGetWithHttpInfo(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/vendor/${vendorId}/services/${vendorServiceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling vendorVendorIdServicesVendorServiceIdGet.');
        }
        // verify required parameter 'vendorServiceId' is not null or undefined
        if (vendorServiceId === null || vendorServiceId === undefined) {
            throw new Error('Required parameter vendorServiceId was null or undefined when calling vendorVendorIdServicesVendorServiceIdGet.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update Vendor Service
     * 
     * @param vendorId the id of the vendor
     * @param vendorServiceId the id of the association between vendor and service
     * @param authorization Authorization Header
     */
    public vendorVendorIdServicesVendorServiceIdPutWithHttpInfo(vendorId: string, vendorServiceId: string, authorization?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/vendor/${vendorId}/services/${vendorServiceId}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling vendorVendorIdServicesVendorServiceIdPut.');
        }
        // verify required parameter 'vendorServiceId' is not null or undefined
        if (vendorServiceId === null || vendorServiceId === undefined) {
            throw new Error('Required parameter vendorServiceId was null or undefined when calling vendorVendorIdServicesVendorServiceIdPut.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];
        
        // authentication (Authorization) required
        if (this.configuration.apiKey)
        {
            headers.set('Authorization', this.configuration.apiKey);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
